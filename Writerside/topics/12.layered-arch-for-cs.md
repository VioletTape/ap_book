# 12. Слоёная архитектура для ИС

<secondary-label ref="wip"/>

Приведенные в этой книге схемы анализа будут очень полезны для разработчиков корпоративных информационных систем. Однако разработка информационной системы (ИС) предполагает не только понимание области. Необходимо приспособиться к миру множества пользователей, баз данных и унаследованных систем. В этой главе рассматриваются архитектурные паттерны для информационных систем. Архитектурный паттерн описывает высокоуровневое разделение системы на основные подсистемы и зависимости между подсистемами. Архитектурный паттерн информационной системы делит систему на уровни (или ярусы). Архитектурные паттерны полезны сами по себе, но они также показывают, как паттерны анализа вписываются в более широкий контекст. В [главе 13](13.application-facade.md) описана техника использования паттернов, приведенных в этой главе.

На заре становления объектной технологии разработке ИС уделялось не так много внимания. Основная проблема заключается в том, что большие объемы зачастую сложной информации должны совместно использоваться многими людьми. Несмотря на то, что эта информация является общей, у разных пользователей разные потребности. Предоставление общей информации, которая может быть адаптирована к местным условиям, является основной задачей больших информационных систем. Кроме того, для удовлетворения постоянно меняющихся потребностей в информации требуется большая гибкость. В большинстве информационных систем доминирует техническое обслуживание, которое в первую очередь связано с удовлетворением меняющихся информационных потребностей. Основное преимущество объектной технологии в этих условиях заключается не в скорости создания новых систем, а в снижении бремени обслуживания [[3](#ref)],

Наиболее фундаментальным вопросом при разработке современной информационной системы является понимание лежащей в ее основе архитектуры программного обеспечения. Широкое представление об архитектуре программного обеспечения, подходящего для информационных систем, должно предшествовать любому обсуждению того, какие методы следует использовать или какие процессы следует рассматривать.

Большинство разработок в области ИБ негласно предполагают _двухуровневую архитектуру_ ([12.1](#12-1-two-tier)), которая возникла на базе интерактивных систем мэйнфреймов и сегодня часто встречается в разработках клиент/сервер. Несмотря на широкое распространение, двухуровневая архитектура имеет множество недостатков, связанных с жесткой привязкой пользовательского интерфейса к физическому расположению данных. _Трехуровневая архитектура_ ([12.2](#12-2-three-tier)), также называемая архитектурой трех схем, решает эту проблему, помещая промежуточный слой между пользовательским интерфейсом и физическими данными. Этот уровень домена тесно моделирует концептуальную структуру проблемной области. Объектная технология особенно хорошо подходит для трехуровневых подходов, а уровень домена может быть размещен как на клиентских, так и на серверных машинах.

Далее мы обратимся к приложениям, которые манипулируют объектами доменного уровня и отображают информацию на пользовательском интерфейсе. Эти две обязанности можно использовать для разделения приложения на _презентацию и логику приложения_ ([12.3](#12-3-presentation-app-logic)). Прикладная логика может быть организована как набор фасадов на доменном уровне, по одному фасаду для каждой презентации. Такое разделение имеет множество преимуществ, а фасады приложений можно использовать для упрощения взаимодействия клиента и сервера.

_Взаимодействие с базой данных_ ([12.4](#12-4-db-interaction)) может осуществляться двумя способами. Уровень домена может отвечать за доступ к базе данных, которая сама управляет своей сохранностью. Это хорошо работает для объектно-ориентированных или простых реляционных систем. При наличии сложных форматов данных или нескольких источников данных может потребоваться дополнительный уровень интерфейса данных.

В основу этой главы положен различный опыт, в частности проект Cosmos Национальной службы здравоохранения Великобритании и система торговли деривативами для одного из лондонских банков.

## 12.1 Двухуровневая архитектура {id="12-1-two-tier"}

Большинство разработок интерактивных ИС организовано, по крайней мере приблизительно, по двухуровневому принципу, как показано на [рис. 12.1](#img12.1). Двухуровневая архитектура делит систему на общую базу данных и несколько приложений. Общая база данных располагается на сервере, который имеет достаточное дисковое пространство и обработку данных, необходимую для удовлетворения высоких требований. База данных содержит данные, необходимые значительной части предприятия, и структурирована для удовлетворения всех потребностей этой части. (Для крупных компаний создание единой общекорпоративной базы данных нецелесообразно, поэтому база данных будет занимать лишь часть). База данных разрабатывается и поддерживается группой баз данных. Хотя здесь используется термин "база данных", следует помнить, что данные часто хранятся в плоских файлах (большинство коммерческих данных по-прежнему хранятся в плоских файлах, таких как [VSAM](https://en.wikipedia.org/wiki/Virtual_Storage_Access_Method)). Таким образом, база данных может относиться к любому источнику данных. 

![](12.1.png){id="img12.1"}

_Приложения напрямую обращаются к базам данных._

**Рисунок 12.1 Двухуровневая архитектура.**

Приложения разрабатываются для конкретного локального использования. Традиционно использовался CICS/COBOL, но в последнее время стали применяться [4GL](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BA%D0%BE%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F#%D0%A7%D0%B5%D1%82%D0%B2%D1%91%D1%80%D1%82%D0%BE%D0%B5_%D0%BF%D0%BE%D0%BA%D0%BE%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5) и популярные средства разработки приложений PowerBuilder и Visual Basic. Эти инструменты предоставляют сложные возможности для разработки систем с графическим интерфейсом, а хороший интерфейс Windows обычно востребован пользователями ПК, которые привыкли к таким возможностям в своих электронных таблицах и текстовых процессорах. Приложения обычно создаются по отдельности. Все необходимые новые возможности работы с данными запрашиваются у группы баз данных.

Двухуровневая архитектура имеет ряд преимуществ. В большинстве организаций есть данные, которые нуждаются в централизованном контроле и последовательном обслуживании. Приложения, интерпретирующие эти данные, нуждаются в гораздо меньшем централизованном контроле. Большая часть работы по ИС заключается в представлении существующих данных в новой и значимой форме.

У двухуровневой архитектуры также много недостатков, большинство из которых присущи современным технологиям. Идея о том, что все данные являются общими, а вся обработка — локальной, в целом верна, но является грубым упрощением. Многие аспекты обработки данных на предприятии являются общими. Базы данных, будь то SQL или более старые, не могут обеспечить полный язык для вычислений. Кроме того, данные не инкапсулируются, что оставляет контроль целостности в руках прикладного программиста. Это затрудняет изменение структуры базы данных, на которой уже работает множество приложений. Эти проблемы решаются с помощью хранимых процедур, которые могут обеспечить поддержку обработки и инкапсуляции данных.

Базы данных часто не могут дать истинное представление о предприятии. Это связано с отсутствием конструктов моделирования, которые распространены в методах концептуального моделирования, но все еще далеки от поддержки в повседневных базах данных. Плоские файлы и иерархические базы данных имеют хорошо известные ограничения на структуру данных. Текущий стандарт для новых разработок, реляционные базы данных, также страдают от высокой стоимости соединений. Модели данных, соответствующие семантике бизнеса, обычно сильно нормализованы и нуждаются в реорганизации, чтобы производительность была приемлемой.

Данные для приложения также вряд ли будут находиться в одной базе данных. Базы данных, даже если они разумно организованы в момент создания, обычно не столь последовательны после нескольких лет изменений в бизнесе и корпоративных реорганизаций. Двухуровневая архитектура требует, чтобы приложения знали, в каких базах данных хранятся те или иные данные, а также структуру данных в каждой базе, которая может быть весьма далека от семантики этих данных.

## 12.2 Трехуровневая архитектура {id="12-2-three-tier"}

На самом деле лучшая архитектура существует уже очень давно. Трехуровневая архитектура была предложена еще в 1970-х годах [[4](#ref)]. Она предусматривает трехуровневый подход, как показано на [рис. 12.2](#img12.2): внешняя схема, концептуальная схема и схема хранения (внутренняя). Схема хранения — это дизайн базы данных, а внешняя схема — это приложения; новый слой — концептуальная схема, которую я называю уровнем домена. Он представляет собой истинную семантику предприятия. Она должна игнорировать ограничения структур хранения данных и их расположения.

![](12.2.png){id="img12.2"}

**Рисунок 12.2 Трехуровневая архитектура.**

Основное преимущество трехуровневого подхода заключается в том, что он позволяет описывать приложения исключительно на основе семантики домена. Им не нужно заботиться о физическом расположении и структуре данных, вместо этого они могут смотреть на логическую картину, которая устраняет эти зависимости. Это также позволяет администраторам данных изменять физическую структуру и расположение данных, не ломая существующие приложения.

Трехуровневая архитектура широко одобрена, но редко реализуется. Основная причина этого — сложность ее использования в существующих технологиях. Существуют инструменты для хранения данных и разработки приложений, но не для реализации доменного уровня. Наиболее полезной разработкой является логическая модель данных, которая обычно рассматривается как необходимый первый шаг в проектировании базы данных. Это позволяет разработчикам учитывать семантику предприятия до того, как они приступят к физическому проектированию. Таким образом, модификации для физического проектирования могут быть сделаны обоснованно.

Нагрузка на данные значительна. Большинство практиков рассматривают уровень домена как логическую модель данных. Они могут заниматься моделированием процессов, но обычно разработчики приложений рассматривают их отдельно. Однако эту точку зрения разделяют не все специалисты по моделированию данных. Сильная школа моделистов семантических данных рассматривает моделирование данных как очень сопоставимое с объектно-ориентированным моделированием, поскольку оно охватывает подтипизацию и производные данные, связывает процессы с объектами, рассматривает процессы как данные и встраивает процессы в семантическую модель.

С развитием объектно-ориентированных методов ярус домена может выйти на первый план. Объекты представляют собой очень хороший способ реализации доменных ярусов. Они поддерживают инкапсуляцию, сложные структурные отношения, правила, процессы и все то, что рассматривается продвинутыми разработчиками семантических моделей. Многоразовые библиотеки классов (или, что еще лучше, фреймворки) также лежат в основе доменного уровня. Ключевыми объектами многократного использования на предприятии являются те, которые описывают домен — фреймворк, реализующий доменное звено (отсюда и термин "фреймворк домена"). Таким образом, объектное моделирование и разработка доменного уровня совпадают очень эффективно.

Вопросы реализации несколько сложнее, но основной принцип по-прежнему работает очень хорошо: Если уровень домена выражен в виде объектно-ориентированной модели и реализован в виде доменного фреймворка, то приложения могут быть написаны на основе этого доменного фреймворка. Это обеспечивает разделение между приложениями и базами данных, которое так необходимо.

### 12.2.1 Расположение уровня домена

В мире клиент/сервер важный вопрос — где должен располагаться этот уровень домена. При двухуровневом подходе прикладное программное обеспечение размещается на клиенте (настольных машинах), а данные — на различных серверах данных. В случае с уровнем домена у нас есть два основных варианта: Мы можем разместить уровень домена на клиентах, или мы можем ввести новый уровень процессоров, который является сервером домена и состоит из одной или многих машин, объединенных в сеть.

Клиентские доменные фреймворки позволяют нам сосредоточить разработку на клиентских машинах, упрощая поддержку систем. Внедрение нового уровня машин вполне может стать новой головной болью для многих магазинов и обеспечить еще один набор машин и систем для обслуживания. Уровень домена предоставляется в виде набора библиотек разработчикам приложений для клиентских систем, которые затем могут писать код приложений по мере необходимости.

Одна из проблем с клиентским уровнем домена заключается в том, что нам может потребоваться выполнить много операций по выбору и обработке данных на клиенте. Это вынуждает нас использовать мощные клиентские машины. По мере того как настольные машины становятся все мощнее, это становится все меньшей проблемой, но мы не можем рассчитывать на такую мощность. Технологии толкают нас на все более компактные машины; некоторые пользователи хотят использовать наладонники и КПК, которые могут ограничивать обработку данных. Часто проще модернизировать серверы, когда требуется большая вычислительная мощность.

Имеющееся программное обеспечение вполне соответствует клиентскому подходу. Smalltalk, как правило, самый полезный язык для приложений ИС, требует пользовательского интерфейса, связанного с уровнем домена, хотя начинают появляться "безголовые" Smalltalk, которые работают на сервере без пользовательского интерфейса.

Уровень домена легче контролировать и обновлять в серверном уровне домена. Если уровень домена находится на клиентах, то любые изменения необходимо рассылать каждому клиенту. Обновления программного обеспечения на сервере могут быть обработаны по более простой схеме. Этот контроль также распространяется на поддержку постоянных данных, особенно тех, которые связаны с доступом к данным.

Нам необходимо рассмотреть вопросы параллелизма. Интересно, что ИС-приложения, вероятно, используют больше параллелизма, чем любой другой стиль программного обеспечения, но при этом меньше всего беспокоятся о нем. Это связано с мощной моделью транзакций, которая обычно очень хорошо обрабатывается базой данных, освобождая прикладного программиста от большинства головных болей, связанных с параллелизмом. Когда вводится уровень домена, мы должны задаться вопросом, где должна находиться граница транзакций. Мы можем разместить ее либо на серверах данных, либо на самом доменном уровне. Логичным местом является уровень домена, но это потребует от нас встроить функции управления транзакциями — непростое дело. Такое размещение также поощряет серверный уровень домена, поскольку фиксация на многих клиентах прагматично выходит за рамки текущей технологии. Я никогда не призываю клиентов создавать свои собственные системы управления транзакциями; эта задача выходит за рамки большинства разработок в области ИС.

Базы данных OO предлагают решение этой проблемы. Основная проблема, с которой сталкиваются IS-сообщества при использовании баз данных OO — это доверие корпоративных данных к новой технологии. Базы данных ОО ответили на это, предоставив шлюзы к традиционным продуктам баз данных. При таком подходе база данных OO может выступать в качестве механизма управления транзакциями, не храня при этом никаких данных. Со временем некоторые данные, особенно сложные и связанные, которыми так хорошо управляет база данных OO, могут быть перенесены в базу данных OO. Тем не менее ключевые корпоративные данные могут оставаться в более традиционных местах до тех пор, пока разработчики этого хотят. Важным предупреждением здесь является то, что информации о многопользовательской производительности баз данных OO очень мало. Многие из заявленных значительных улучшений производительности баз данных OO основаны на небольших однопользовательских базах данных. Любой, кто использует базу данных OO, даже если она предназначена только для управления транзакциями, должен провести сравнительный анализ, прежде чем брать на себя обязательства по использованию базы данных.

Если используется только одна база данных OO, то уровень хранения данных эффективно сворачивается в уровень домена. Это допустимо при условии, что это эффективная архитектура и что расширения системы для поддержки других баз данных могут быть сделаны таким образом, что эти другие базы данных будут предоставлены за уровнем домена так, что они не будут видны из приложений.

## 12.3 Логика представления и приложения {id="12-3-presentation-app-logic"}

Трехуровневая архитектура дает ряд очень важных преимуществ. Много внимания было уделено тому, как может быть построен уровень домена, и значительная часть моделирования ОО непосредственно применяется к этому ключевому уровню. Однако мало что было сказано о приложениях. Приложения создаются путем сборки многократно используемых компонентов на уровне домена, и для этой задачи также существуют рекомендации, хотя они часто не описаны подробно.

Как правило, в современной среде программист разрабатывает приложение в среде графического интерфейса, которая построена на уровне домена. Это требует знания среды GUI и уровня домена, а сложный уровень домена может сделать кривую обучения довольно крутой. Программирование во многих графических средах (таких как Visual C++) также может быть довольно сложным.

Рассмотрим относительно простой пример финансового учреждения, имеющего портфель производных контрактов между долларами США (USD) и японскими иенами (JPY). Такая организация заинтересована в управлении риском, связанным с таким портфелем. На этот риск могут влиять несколько факторов, включая обменный курс спот, волатильность обменного курса и процентные ставки по двум валютам. Чтобы учесть этот риск, аналитик хочет посмотреть на цену портфеля при различных комбинациях этих факторов. Один из способов сделать это — использовать сетку, показанную на [рис. 12.3](#img12.3). Аналитик выбирает две переменные для анализа, устанавливает для них различные значения и видит матрицу, показывающую стоимость портфеля при различных комбинациях значений.

![](12.3.png){id="img12.3"}

**Рисунок 12.3 Пример приложения для управления рисками по деривативам.**

Каковы задачи обработки и как их разделить между прикладным и доменным уровнями? Одна из фундаментальных задач — определение стоимости контракта на дериватив, сложный процесс, обычно выполняемый с помощью анализа Блэка-Шоулза [[2](#ref)]. Этот процесс будет широко использоваться любой системой в среде торговли деривативами, поэтому его следует отнести к уровню домена. Другой распространенной задачей является оценка стоимости многих контрактов, объединенных в портфель, которая обычно помещается в уровень домена. Следующая задача — построить сетку значений из параметров (верхний, нижний, размер шага, количество шагов) в сетке. Эта задача уникальна для данного экрана отчета о рисках, поэтому по логике должна быть частью прикладного уровня, вместе с кодом, который создает и управляет графическим интерфейсом.

Задача построения матрицы довольно сложна и требует более детального рассмотрения. Она включает в себя установку различных параметров, поддержание их согласованности, а затем использование параметров для построения сетки значений. Этот процесс может и должен быть отделен от отображения на экране графического интерфейса. Поэтому я рекомендую разделить уровень приложения на два: уровень представления и уровень прикладной логики, как показано на рис. 12.4.

![](12.4.png){id="img12.4"}

**Рисунок 12.4 Разделение уровня приложения на представления и логику приложения**

Разделить обязанности этих двух уровней довольно просто. Уровень предварительной отправки отвечает только за пользовательский интерфейс. Он обрабатывает окна, меню, шрифты, цвета и все позиционирование на экране или бумаге. Обычно он использует фреймворк пользовательского интерфейса, такой как MFC или MacApp. Он не выполняет никаких вычислений, запросов или обновлений на уровне домена. Ему вообще не нужно иметь никакой видимости для уровня домена. Уровень прикладной логики не выполняет никакой обработки пользовательского интерфейса. Он отвечает за все обращения к уровню домена и любую обработку, кроме обработки пользовательского интерфейса. Он выбирает информацию из базового доменного уровня и упрощает ее до той формы, которая требуется для представления. Таким образом, сложные взаимосвязи доменного уровня скрываются от представления. Кроме того, уровень прикладной логики выполняет преобразование типов. Презентация обычно имеет дело только с небольшим набором общих типов (integer, real, string и date, а также классы коллекций, используемые в программном обеспечении). Логика приложения предоставляет только эти типы и отвечает за преобразование базовых типов домена в эти типы и интерпретацию любых обновлений, запрашиваемых представлением.


Полезным способом организации яруса прикладной логики является разработка серии фасадов. <tooltip term="GoFp">Фасад</tooltip> — это тип, предоставляющий упрощенный интерфейс к сложной модели. Мы можем подготовить фасад для каждого представления. Фасад имеет функцию для каждого элемента соответствующего пользовательского интерфейса. Таким образом, каждая предварительная презентация имеет простой интерфейс к доменной модели, который минимизирует любую обработку презентации, кроме пользовательского интерфейса. (В [главе 13](13.application-facade.md) рассматривается техника проектирования таких фасадов).

На [рис. 12.5](#12-5-concluding-thoughts) показано, как эта организация работает для экрана отчета о рисках, о котором говорилось выше. Нам нужны два класса: представление отчета о рисках и фасад отчета о рисках. Презентация создает макет экрана и управляет взаимодействием пользователя с ним. Фасад предоставляет базовую структуру, которая имитирует презентацию. Он содержит операции для получения и установки параметра, верхнего, нижнего значения, количества шагов и размера шага для координат x и y сетки. Фасад содержит правила, необходимые для обеспечения надлежащей согласованности этих значений (например, инвариант `xUpper — xLower == xNumberOfSteps * xStepSize`). Он также предоставляет метод для возврата сетки ответов. В идеале он возвращает одну матрицу, используя общий класс матриц. (Если по каким-то причинам это недоступно или нежелательно, то фасад предоставляет операции для получения конкретных ячеек, но класс матрицы многократного использования, по сути, новый вид коллекции, обычно является лучшим решением).

![](12.5.png){id="img12.5"}

**Рисунок 12.5 Диаграмма взаимодействия, обобщающая взаимодействие между уровнями представления, фасада и домена.**

Метод getResultMatrix на фасаде проверяет, достаточно ли информации было предоставлено презентацией (если нет, он может добавить значения по умолчанию), а затем просит доменное звено оценить портфель с различными комбинациями параметров. Доменный уровень заносит результаты в матрицу и возвращает ее презентации.

Установка параметров — это пример использования преобразования типов. В качестве параметров в этот список могут быть помещены различные объекты, включая спот USD/JPY, волатильность USD/JPY, процентную ставку USD и процентную ставку JPY. (Список зависит от валют контрактов в портфеле). Фасад предоставляет соответствующие строки для представления, переводя их из типов на уровне домена (см. [раздел 13.5](13.application-facade.md#13-5-type-conversions)). Фасад обычно предоставляет список таких строк, которые презентация может поместить в свое всплывающее меню. Затем презентация может выбрать строку. Фасад соотносит выбранную строку с нижележащими объектами домена (с этим прекрасно справляется словарь). Таким образом, пользовательский интерфейс полностью изолирован от доменной модели.

В этой ситуации видимости между доменами определяются так, как показано на [рис. 12.6](#img12.6). Видимость идет только от представления к прикладной логике и доменному уровню. Такая линия видимости ценна тем, что она полностью изолирует уровень домена от приложений, которые на него полагаются. Однако может возникнуть проблема, если презентация должна автоматически обновляться при изменении модели домена. Один из вариантов — опрашивать презентацию через регулярные промежутки времени, но это может оказаться довольно запутанным. Лучшим вариантом является использование паттерна <tooltip term="GoFp">наблюдателя</tooltip>. Это позволяет автоматически обновлять фасад и презентацию, не нарушая правил видимости.

![](12.6.png){id="img12.6"}

**Рисунок 12.6 Видимость между категориями презентации, фасада и домена.**

### 12.3.1 Преимущества разделения логики представления/применения

В принципе, многослойность — хорошая идея, но у нее есть и недостатки: для создания слоя требуется дополнительная работа, а его использование может привести к снижению производительности. Важный вопрос — стоят ли преимущества затрат?

Одно из преимуществ связано с разными стилями программирования, используемыми в этих двух слоях. Программирование графического интерфейса может быть очень сложным, требующим знания фреймворков графического интерфейса и умения правильно их использовать. Если требуются новые элементы управления GUI, программирование становится еще более сложным. С другой стороны, разработка GUI может быть довольно простой, если у нас есть хороший конструктор экранов GUI, позволяющий нам рисовать элементы управления на экране и создавать обработчики событий, которые обычно передаются как вызовы фасада приложения. В любом случае организации, занимающиеся разработкой, могут использовать специалистов по графическому интерфейсу, которым не нужно много знать о модели домена. Точно так же программистам фасада не нужно ничего знать о том, как работает система GUI, их задача — обеспечить правильное взаимодействие с типами домена. Таким образом, мы видим, что могут быть разработчики GUI, которые понимают среду пользовательского интерфейса, но не должны знать ничего о доменной модели, и разработчики фасадов, которые понимают доменную модель, но не нуждаются в знаниях о разработке GUI. Разделение на презентацию и прикладную логику разделяет различные необходимые навыки, позволяя разработчикам изучать меньше, чтобы внести свой вклад.

Разделение позволяет разрабатывать несколько презентаций на основе одного фасада; это особенно удобно, когда требуются индивидуальные экранные или бумажные макеты, содержащие одну и ту же информацию. Когда используются инструменты для создания экранов и отчетов, это позволяет быстро создавать новые стили презентаций.

Фасады обеспечивают хорошую платформу для тестирования. Когда фасад и презентация объединены, базовые вычисления можно протестировать только через графический интерфейс, что требует ручного тестирования (или программного обеспечения для тестирования графического интерфейса для регрессионного тестирования). Когда они разделены, для интерфейса фасада можно написать тестовый пакет. Таким образом, остается только код представления, который нужно тестировать с помощью более неудобных инструментов. Разделение тестирования подкрепляет мысль о том, что оба слоя можно создавать отдельно, хотя презентация должна быть определена до создания фасада.

### 12.3.2 Растягивание фасадов в средах клиент/сервер

Фасад ценен как фокусная точка для взаимодействия клиента и сервера, если уровень домена базируется на сервере. Полезной техникой в таких случаях является "растягивание" фасада между клиентом и сервером, размещая класс фасада и на клиенте, и на сервере. Когда пользователь открывает презентацию, соответствующий фасад открывается на стороне клиента. Клиентский фасад передает запрос на серверный фасад. Серверный фасад проходит процесс создания, извлекая информацию из классов домена. Когда вся информация для фасада готова, серверный фасад отправляет всю информацию для фасада клиенту. Поскольку серверный и клиентский фасады могут находиться в разных объектных пространствах, между двумя классами фасадов может происходить ряд частных коммуникаций. Пользователь может взаимодействовать с презентацией, которая будет обновлять клиентский фасад при каждом изменении. Эти изменения не передаются на фасад сервера до тех пор, пока пользователь не зафиксирует их. В этот момент измененный объект фасада передается обратно на сервер, а серверный фасад обновляет уровень домена, как показано на рис. 12.7.

![](12.7.png){id="img12.7"}

**Рисунок 12.7 Диаграмма взаимодействия [рисунка 12.3](#img12.3) с использованием вытянутых фасадов.**

Смысл растягивания фасада в том, что он обеспечивает единую точку обращения для взаимодействия клиента и сервера. Если клиентский фасад (или презентация) обращается к классам домена сервера напрямую, то для наполнения клиента потребуется множество вызовов по сети. Эти сетевые вызовы могут существенно повлиять на производительность. Фасады могут иметь методы для создания одного пакета передачи и интерпретации такого пакета в данные фасада. Затем мы можем передавать всю информацию в одном сетевом вызове.

Различные обязанности фасада могут быть разделены между классами клиента и сервера. Только серверный фасад должен отвечать за взаимодействие с доменной моделью. Оба класса должны иметь возможность отправлять и получать информацию друг от друга. В идеале только клиентский фасад должен выполнять операции по поддержке представления. Однако на практике я считаю целесообразным дать обоим классам одинаковый интерфейс, чтобы облегчить тестирование (то есть они должны быть одного типа). Обеим сторонам требуются операции загрузки и сохранения. Клиентский фасад реализует эти операции, взаимодействуя с серверным фасадом, а сервер реализует их, взаимодействуя с доменной моделью.



## 12.4 Взаимодействие с базой данных {id="12-4-db-interaction"}

Нам нужно тщательно продумать, как интегрировать базы данных и унаследованные приложения в эту структуру. Самый простой случай — использование объектной базы данных. В этом случае простым подходом является простая интеграция базы данных в уровень домена. Объектная база данных предоставляет средства для персистентности, управления транзакциями и другие возможности, о которых не должен беспокоиться ни один корпоративный программист.

Однако лишь немногие приложения в службе ИБ настолько просты. Многие организации ИС с недоверием относятся к объектным базам данных и неохотно размещают в них важные данные. Отчасти это объясняется их новизной, но также и сложностью. Реляционные таблицы относительно легко вскрыть, если что-то пойдет не так. Объектные базы данных, с огромным количеством дисковых указателей, гораздо сложнее.

Даже если бы объектные базы данных были уверенным выбором для новых разработок, все равно остается проблема существующих данных. Даже реляционные базы данных, несмотря на их нынешнее положение в качестве проверенной технологии для разработки баз данных, еще не достигли положения, позволяющего управлять большинством корпоративных данных. Подавляющее большинство корпоративных данных находится в иерархических базах данных, плоских файлах и т.п. Объектные системы должны взаимодействовать с этими системами, по мере необходимости принимая информацию и учитывая тот факт, что для получения целостной картины необходимо обращаться ко многим системам. Существует два широких подхода: позволить доменной модели взаимодействовать с источниками данных или использовать слой интерфейса базы данных.

### 12.4.1 Связывание уровня домена с источниками данных

Рассмотрим простой случай автономной системы, которая должна использовать реляционную базу данных для хранения данных. Мы можем спроектировать реляционную базу данных специально для поддержки доменной модели. Сначала мы должны спроектировать уровень домена и на его основе разработать схему базы данных. Для всех систем, кроме самых простых, невозможно просто взять каждый тип объекта в доменной модели и превратить его в реляционную таблицу. Несмотря на свое название, реляционные базы данных имеют проблемы со связью данных, поскольку вычисление соединений занимает много времени. Таким образом, хороший реляционный дизайн должен значительно денормализоваться, чтобы получить хорошую производительность. Модель домена служит отправной точкой для проектирования базы данных, но для качественного проектирования базы данных необходимо время. Результирующая схема базы данных может выглядеть совсем иначе, чем исходные диаграммы объектов.

Очевидный способ связать уровень домена с базой данных заключается в том, чтобы классы домена умели создавать себя на основе базы данных. Классы могут иметь процедуры загрузки, которые извлекают данные из базы данных и используют их для создания и связывания каркаса. Важно, чтобы приложения не были вовлечены в такое поведение. Когда приложение запрашивает объект, уровень домена должен посмотреть, есть ли он в памяти. Если нет, то он должен сам создать объект из базы данных. Приложению не нужно знать, как происходит это взаимодействие.

Исключение составляют случаи, когда приложениям требуется определенная конфигурация данных для работы, и эти данные могут быть получены из базы данных за один шаг в самом начале, что повышает производительность. В этом случае доменному уровню может быть полезно предлагать специфические для приложения запросы нагрузки, которые дают приложению возможность сообщить доменному уровню, что от него хотят получить. В некоторой степени это нарушает принцип, согласно которому доменное звено не должно знать, какие приложения его используют, но в некоторых случаях выигрыш в производительности может быть убедительным.

### 12.4.2 Уровень интерфейса базы данных

Прямая связь между уровнем домена и базой данных имеет ряд существенных проблем. Она может чрезмерно усложнить доменные классы, наделив их двумя независимыми обязанностями: предоставлять исполняемую модель бизнеса и извлекать данные из базы данных. Код, необходимый для взаимодействия с базой данных, может быть весьма значительным, чрезмерно раздувая классы. Если данные необходимо получать из нескольких баз данных и каналов, то эта проблема становится критической.

Ответ, конечно, заключается в добавлении еще одного уровня — уровня интерфейса базы данных, который отвечает за загрузку уровня домена данными из базы данных и за обновление базы данных при изменении домена. Этот уровень также отвечает за обработку фидов и других унаследованных взаимодействий.

Во многом интерфейсный уровень базы данных очень похож на уровень логики приложения. В обоих случаях фасад предоставляется сложному уровню домена, чтобы справиться с менее мощным представлением. Этот фасад выбирает и упрощает структуру объектов и выполняет преобразование типов к более простой внешней системе типов. Опять же, уровень домена не должен знать о различных представлениях, которые могут быть в нем реализованы. Обычно классы интерфейсов баз данных основываются на источнике данных, с которым они работают. Класс интерфейса базы данных может быть создан для каждой таблицы в реляционной базе данных или для каждого типа записи в ленте. Библиотеки классов для поддержки взаимодействия с базами данных часто поддерживают такое соответствие.

Самое большое различие между этим уровнем и уровнем логики приложения заключается в инициировании активности. В пользовательском интерфейсе действие пользователя заставляет презентацию инициировать активность. Поскольку презентация имеет видимость логики приложения, ей несложно вызвать логику приложения. Инициация активности следует за линией видимости. Однако с интерфейсом базы данных дело обстоит иначе. Доменный уровень начинает процесс с желания сохранить себя, но мы не хотим, чтобы доменная модель видела базу данных. Таким образом, инициация активности противоположна желаемой видимости. Одним из решений является повторное использование <tooltip term="GoFp">наблюдателя</tooltip>, но это может привести к очень большому объему трафика сообщений.

Альтернативой является расширение архитектуры с помощью интерфейсного брокера, который виден на уровне домена. Этот брокер предоставляет очень маленький интерфейс, который допускает только сообщения, инициирующие интерфейс базы данных. Обычно это могут быть такие общие вызовы, как loadMe(anObject) и saveMe(anObject), которые передают всю ответственность за обработку запроса на уровень интерфейса базы данных. Ответственность брокера заключается в том, чтобы передать этот запрос классу в интерфейсе базы данных, который может наилучшим образом обработать запрос. Таким образом, если у нас есть спот-контракты, хранящиеся в одной таблице базы данных, и обычные опционы, хранящиеся в другой, интерфейсный брокер сначала опрашивает объект, чтобы выяснить, какой из них является объектом, а затем передает запрос соответствующему классу интерфейса базы данных, как показано на рис. 12.8 и 12.9.

![](12.8.png){id="img12.8"}

**Рисунок 12.8 Диаграмма взаимодействия, иллюстрирующая типичное взаимодействие уровня домена с источником данных.**

![](12.9.png){id="img12.9"}

**Рисунок 12.9 Категории интерфейсного уровня базы данных.**

Преимущества такого наслоения аналогичны преимуществам наслоения в других местах. Опять же, ответственность разделена полезным образом, отделяя интерфейс данных от модели предприятия. Форматы таблиц или изменения в подаче данных могут быть выполнены без изменения модели домена. Это особенно важно, когда форматы таблиц находятся вне контроля проектной группы или когда есть вероятность, что структура данных может измениться для повышения производительности. Чем выше волатильность этих источников, тем важнее использовать промежуточный слой.

Для доступа к различным базам данных могут потребоваться различные инструменты и навыки. Существуют специализированные библиотеки классов для взаимодействия с продуктами баз данных. Может потребоваться знание SQL и конкретного формата базы данных. Другие базы данных (многомерные, иерархические) имеют свои собственные интерфейсы и структуры, которые необходимо изучить. Разделение этого взаимодействия, особенно при наличии большого количества различных источников данных, позволяет членам команды сосредоточиться на тех областях, в которых они наиболее сильны.

## 12.5 Заключительные размышления {id="12-5-concluding-thoughts"}

Создание крупных систем ИБ в среде клиент/сервер по-прежнему остается сложным занятием с множеством подводных камней. Многие из них связаны с использованием двухуровневой архитектуры, которая хорошо подходит для небольших систем, но плохо масштабируется. Трехуровневая архитектура значительно улучшает ситуацию и хорошо поддерживается объектной технологией. В табл. 12.1 приведены краткие описания трех уровней.

| **УРОВЕНЬ**           | **ОПИСАНИЕ**                                                                                                                                                                                                                                                                                                                     |
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Домен**             | Прямая модель бизнес-объектов, применимая ко всему домену. Независимая от отдельных приложений и источников данных.                                                                                                                                                                                                              |
| **Логика приложения** | Выбор и упрощение модели домена для приложения. Не содержит кода пользовательского интерфейса, но предоставляет набор фасадов доменных уровней для пользовательского интерфейса. Преобразует богатые типы доменных уровней в типы, необходимые для представления.                                                                |
| **Презентация**      | Выполняет форматирование информации из фасада приложения в графический интерфейс или бумажный отчет. Занимается только пользовательским интерфейсом и не имеет знаний о базовом уровне домена.                                                                                                                                   |
| **Интерфейс данных**   | Отвечает за перемещение информации между источниками данных и доменным уровнем. Предоставляет простой интерфейсный брокер для доменного уровня, который будет отправлять запросы. Имеет видимость как доменного уровня, так и источников данных. Разделяется на подсистемы в зависимости от типа используемых источников данных. |

**Таблица 12.1 Краткое описание слоев и их назначения.**

Разделение яруса приложения для отделения логики приложения от пользовательского интерфейса — ценная техника. Его преимущества включают повторное использование логики приложения для различных графических интерфейсов, простоту тестирования, управление производительностью для систем клиент/сервер и поддержку более специализированного персонала разработчиков. Промежуточный уровень также полезен для доступа к данным, особенно при наличии множества сложных источников данных.

Некоторые классы должны использоваться на всех уровнях. К ним относятся общие фундаментальные типы (integer, date, quantity), коллекции, а также некоторые фундаментальные типы, специфичные для конкретной области.

## Ссылки {id="ref"}

1. Gamma, E., R. Helm, R. Johnson, and J. Vlissides. _Design Patterns: Elements of Reusable Object-Oriented Software._ Reading, MA: Addison-Wesley, 1995.

2. Hull, J.C. _Options, Futures, and Other Derivative Securities (Second Edition)._ London: Prentice-Hall International, 1993.

3. Kain, J.B. _Measuring the return on investment of reuse._ Object Magazine, 4, 3 (1994), pp. 49–54.

4. Tsichiritzis, D.C., and A. _Klug. The ANSI/X3/SPARC DBMS framework: report of the study group on database management systems._ Information Systems, 3 (1978).  
