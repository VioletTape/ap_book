# 11. Торговые пакеты

<secondary-label ref="wip"/>

Чтобы полностью понять эту главу, вам необходимо сначала прочитать [главы 9](9.traging.md) и [12](12.layered-arch-for-cs.md). Разработка больших информационных систем сопряжена с особыми трудностями. Основной способ работы с крупномасштабной системой заключается в ее декомпозиции на более мелкие системы. Это требует определенной формы архитектурного моделирования, о чем говорится в разделе A.5.

Первым организационным инструментом любой информационной системы является многоуровневая архитектура, рассмотренная в [главе 12](12.layered-arch-for-cs.md). Эта архитектура определяет многие пакетные подразделения системы. Однако в больших системах модель домена становится слишком большой для одного пакета. В этой главе мы рассмотрим, как можно разделить большую доменную модель. Концепции пакета и видимости (см. [раздел A.5](Techniques.md#a-5)) снова используются в качестве основного инструмента для разделения. Примерами служат концепции торговли из [главы 9](9.traging.md). Первый пример рассматривает, как организовать модели сценариев и портфелей. Основная проблема заключается в наличии _нескольких уровней доступа к пакету_ ([11.1](#11-1-multiple-access)). Приложение для управления рисками использует сценарии для получения информации, необходимой для оценки портфелей. Другому приложению требуется настройка и управление сценариями. Обоим приложениям нужен доступ к типам сценариев, но им нужны разные уровни доступа. Разные клиенты, нуждающиеся в разных интерфейсах, — распространенная проблема. Решения включают разрешение пакету иметь несколько протоколов и использование разных пакетов.

Отношения между контрактами и сторонами поднимают проблему _взаимной видимости_ ([11.2](#11-2-mutual-visibility)). Предлагаются три решения: односторонняя видимость между контрактом и стороной, помещение их обоих в один пакет или помещение их в отдельные взаимно видимые пакеты. Все три решения имеют существенные недостатки.

Последний паттерн исследует _пакеты подтипов_ ([11.3](#11-3-subtyping-packages)), рассматривая, как расположить производные, рассмотренные в [главе 10](10.derrivative-contracts.md), в структуре пакета. Этот паттерн иллюстрирует, что подтипы могут быть помещены в пакет отдельно от своих супертипов с видимостью от подтипа к супертипу.

## 11.1 Несколько уровней доступа к пакету {id="11-1-multiple-access"}

Портфели формируются из контрактов с использованием рыночных индикаторов в качестве описаний. Сценарии используются независимо для разработки цен на рыночные индикаторы. Портфели и контракты должны использовать сценарии для определения своей стоимости, но сценарии не нуждаются в знании портфелей и контрактов, как показано на рис. 11.1.

![](11.1.png){id="img11.1"}

**Рисунок 11.1 Первоначальная картина видимости пакетов.**

Для проведения оценок портфелю требуется только цена рыночного индикатора. Пакету портфеля не нужно знать, как настроен сценарий. Таким образом, хотя тип элемента сценария должен быть виден портфелю, чтобы можно было отправить сообщение getQuote, нет необходимости видеть подтипы с определением того, как формируется котировка. На самом деле мы можем пойти дальше и сказать, что даже элемент сценария не является полезным для портфеля. Лучшим подходом было бы представить интерфейс портфеля, как показано на рис. 11.2. Этот интерфейс имеет отображение с ключом (см. [раздел 15.2](15.association-patterns.md#15-2-keyed)) на сценарий, который принимает в качестве аргумента рыночный индикатор. Поскольку никакие другие свойства элемента сценария не важны, интерфейс для пакета портфеля прост.

![](11.2.png){id="img11.2"}

_Это лучший интерфейс для пакета портфеля, которому не нужно знать об элементах сценария._

**Рисунок 11.2. Интерфейс пакета сценария, скрывающий элементы сценария.**

 

Такой подход требует двух разных типов сценарных пакетов: один для интерфейса с портфелем, другой — для настройки сценариев. Таким образом, необходимо нечто большее, чем простое назначение типов пакетам. Ближайший и очевидный подход — разделить типы в пакете сценария на публичные и частные. Публичные типы — это те, которые видны другим пакетам, имеющим видимость в пакет сценария (например, портфель). Частные типы видны только типам внутри пакета сценария. В данном случае сценарий является публичным типом, а элемент сценария — частным типом. Эту логику можно распространить и на операции. Публичные операции могут быть публичными внутри пакета и публичными для других пакетов. Хотя это и представляет собой тонкую степень контроля, ее может быть слишком сложно поддерживать. Искусство хорошего дизайна видимости заключается в том, чтобы выбрать такую степень видимости, которая будет достаточно тонкой, чтобы быть полезной, но не настолько тонкой, чтобы превратить портфель в кошмар для управления. (Вещи, которыми сложно управлять, как правило, не управляются, что приводит к появлению устаревших и бесполезных моделей).

Одна из проблем такого подхода заключается в том, что пользователям требуется программное обеспечение для создания сценариев и работы с ними. Для этого требуются компоненты на уровнях прикладной логики и представления, как обсуждалось в [главе 12](12.layered-arch-for-cs.md). Таким образом, модель должна включать пакет приложений для управления сценариями, отдельный от пакета сценариев. На [рис. 11.3](#img11.3) показано добавление пакета приложений для управления сценариями и пакета приложений для управления рисками. Однако такой подход не будет работать с описанным выше подходом "государственный/частный", поскольку для приложения управления сценариями требуются частные типы пакета сценариев. Хотя и управление портфелем, и управление сценариями требуют видимости пакета сценариев, им нужны разные типы видимости.

![](11.3.png){id="img11.3"}

_Проблема заключается в том, что приложению для управления сценариями требуется гораздо больший интерфейс к пакету сценариев, чем пакету портфеля._

**Рисунок 11.3. Добавление пакетов приложений на [Рисунок 11.1](#img11.1).**


Одно из решений этой проблемы, предложенное Вирфсом-Броком, позволяет пакету иметь более одного протокола.(Вирфс-Брок использует термин контракт, который в данном примере смущает, поэтому я использую протокол). В нашем оригинальном шаблоне мы задали протокол как набор операций; однако вполне разумно сделать его просто набором типов, чтобы упростить контроль видимости. Использование отдельных протоколов приводит к диаграмме, подобной [рис. 11.4](#img11.4), на которой сценарий имеет два протокола: Тот, который используется портфелем, допускает только мелкий протокол, в то время как приложение для управления сценарием использует более глубокий протокол. Протоколы показаны полукруглыми портами на коробке пакета. (Я показываю порты только на пакетах с более чем одним протоколом).

![](11.4.png){id="img11.4"}

_Каждый протокол подразумевает отдельный интерфейс._

**Рисунок 11.4 Пакеты из [рисунка 11.3](#img11.3) с протоколами.**



Использование отдельных протоколов — один из способов решения проблемы множественной видимости. Другой способ — ввести дополнительный пакет, как показано на рис. 11.5. Элемент сценария и его подтипы перемещаются из пакета сценария в пакет структуры сценария. Пакет сценария содержит только тип сценария и его простые ассоциации. Пакет портфеля имеет видимость только пакета сценария, в то время как приложение управления сценариями видит и сценарий, и пакет структуры сценария. Мы можем определять новые сценарии с помощью дополнительной видимости.

![](11.5.png){id="img11.5"}

**Рисунок 11.5. Использование дополнительного пакета для структуры сценария.**

Внимательному читателю может прийти в голову вопрос, нужно ли сценарию иметь видимость структуры сценария. Ответ на запрос о цене требует использования внутренней структуры. Интригующий аспект наследования и полиморфизма проявляется в этих видимостях. Пакет сценария может содержать класс сценария, который определяет интерфейс, необходимый всем пакетам, имеющим видимость сценария. Однако этот сценарный класс не обязательно должен реализовывать весь интерфейс (и поэтому является абстрактным). Мы можем поместить второй сценарный класс в пакет структуры сценария, который реализует интерфейс. Этот второй класс сценария имеет полную видимость содержимого структуры сценария. Любой объект сценария, используемый другим пакетом, является экземпляром класса сценария структуры сценария, но клиенты класса этого не осознают. Все, что они видят, — это объект, соответствующий интерфейсу сценарного класса пакета сценариев. Возможно, стоит ввести обозначение, показывающее, где происходит подобное подклассирование через границы пакетов, хотя я его не использую.

Поэтому, когда объект в пакете портфеля отправляет сообщение сценарию, на самом деле он отправляет сообщение экземпляру конкретного класса сценария, который находится в пакете управления сценариями. Однако вызывающая сторона думает, что вызывает экземпляр абстрактного класса сценария, который находится в пакете scenario. Объект может отправить сообщение объекту в пакете, который он не видит, при условии, что вызываемый объект является подклассом класса в пакете, который видит вызывающий объект.

Следствием этого является то, что видимость не отражает зависимостей от компиляции или загрузки. Хотя структура сценария не видна сценарию, сценарий нуждается в структуре сценария для функционирования (строго говоря, он зависит от некоторого пакета, реализующего интерфейс). Структура сценария содержит конкретные подклассы сценария, без которых пакет сценария не может работать.

Хотя в этой схеме требуется два разных класса сценариев, они могут соответствовать одному типу сценария. В этом случае предоставляется новый подтип, позволяющий получить доступ к внутренней структуре сценария для таких приложений, как управление сценариями. Однако можно иметь один тип, когда другим типам не нужно вызывать специальные функции, присутствующие только в подтипе.

## 11.2 Взаимная видимость {id="11-2-mutual-visibility"}

Добавление пакетов для контрактов и сторон вызывает более сложные вопросы. В случае со сценариями и портфелями отдельные пакеты использовались по двум причинам. Во-первых, сценарии и портфели кажутся отдельными кусками модели. Они сами по себе являются сложными разделами, которые как бы составляют единицу труда. Во-вторых, для построения модели сценариев нам не нужны знания о портфелях. Вторая причина является самой сильной, поскольку она приводит к наглядным связям, показанным на [рисунке 11.1](#img11.1).

Разумно заключить, что контракты можно составлять и моделировать без знания портфелей. Контракты можно регистрировать независимо от динамической структуры портфеля, используемого для их группировки в целях оценки риска, как показано на рис. 11.6.

![](11.6.png){id="img11.6"}

_Приложению для управления рисками нужны оба пакета, а приложению для ценообразования достаточно знать только о контрактах._

**Рисунок 11.6 Пакеты для портфеля и контракта.**



Отношения между сторонами и контрактами представляют собой более серьезную проблему. Мы можем привести аргументы в пользу того, чтобы помещать стороны в отдельный пакет. Ряд приложений может искать информацию о сторонах, не желая ничего знать о заключаемых с ними сделках. Общий пакет партии может содержать общую информацию о партиях, используемую многими дилинговыми системами, подобно базе данных контактов. Таким образом, мы можем сделать вывод, что пакет партии является ценным.

Каковы будут отношения между партиями и пакетами контрактов? Стороне было бы полезно знать, какими контрактами она занимается, а контракту — кто является стороной контракта. Это подразумевает взаимную видимость между стороной и контрактом, как показано на рис. 11.7. Но взаимная видимость может вызвать проблемы в пакетной модели. В целом мы стараемся разрабатывать пакетные модели с многоуровневой архитектурой и простыми линиями видимости. Многие считают, что в такой архитектуре никогда не должно быть циклов в отношениях видимости, потому что цикл нарушает правило четких слоев. Взаимная видимость — это простейший случай цикла.

![](11.7.png){id="img11.7"}

_Некоторые приложения нуждаются только в одном из пакетов — пакете партии или пакете договора, но оба эти пакета нуждаются друг в друге. Это может подразумевать взаимную видимость. Если взаимная видимость неприемлема, мы можем выбрать одно направление или объединить пакеты._

**Рисунок 11.7 Отдельные пакеты партии и контракта.**


Чтобы устранить взаимную видимость, мы должны либо изменить характеристики партии или контракта так, чтобы только одна из них знала о другой, либо объединить их в один пакет. Каждая альтернатива имеет свои компромиссы.

Преимущество ограничения видимости между типами Группа и Контракт в одном направлении заключается в том, что это уменьшает связь между этими двумя типами (и их соответствующими пакетами). Если мы удалим отображения от партии к ее контрактам (сделав ассоциацию односторонней), мы сможем работать над пакетом партии без необходимости знать что-либо о контрактах. Это уменьшает связанность (партия больше не связана с контрактом), что является преимуществом. Однако пользователь, который хочет узнать, по каким контрактам конкретная сторона является контрагентом, должен просмотреть каждый контракт и использовать отображения на сторону для формирования набора. Таким образом, мы уменьшили сложность для разработчика пакета партии, но увеличили сложность для разработчика любого приложения, которому необходимо использовать оба типа. Абсолютно правильного ответа здесь нет; мы должны рассмотреть компромиссы в каждом направлении и решить, какой выбор будет менее обременительным.

<tip>
    <p>
        <b>Принцип моделирования</b>
    </p>
    <p>Решение между односторонней и двусторонней ассоциацией — это компромисс между меньшим объемом работы для разработчиков соответствующих типов (за счет уменьшения их связи) и удобством для пользователей типов.</p>
</tip>


Если мы примем решение в пользу двусторонней ассоциации, то единственным способом устранить взаимную видимость будет объединение пакетов партии и контракта. Однако это не лишено недостатков. На рис. 11.7 видно, что пакету управления контактами нужно знать только о сторонах, но не о контрактах. Объединение этих двух пакетов приведет к удалению этой информации. Управление контактами будет вынуждено иметь большую видимость, чем ему необходимо.

Такая ситуация заставляет меня не запрещать взаимные видимости или другие циклы. Безусловно, циклы должны быть сведены к минимуму. Однако полное их устранение приводит либо к вынужденному компромиссу между односторонними и двусторонними ассоциациями, либо к большим пакетам, клиентам которых не нужна вся видимость, которая подразумевается.

<tip>
    <p>
        <b>Принцип моделирования</b>
    </p>
    <p>Если пакету нужна видимость только части другого пакета, рассмотрите возможность разделения последнего пакета на два взаимно видимых пакета.</p>
</tip>

На [рис. 11.8](#img11.8) показан еще один пример такой ситуации. Продукт (см. [раздел 10.3](10.derrivative-contracts.md#10-3-product)) добавлен в свой собственный пакет. Предыдущие аргументы приводят к взаимной видимости между продуктом, стороной и контрактом. Это приводит к достаточно тесному взаимодействию пакетов доменных моделей. Однако прикладные пакеты должны видеть только часть картины, и у каждого прикладного пакета свои потребности. Три взаимно видимых пакета позволяют нам четко определить эти потребности.

![](11.8.png){id="img11.8"}

_И снова различные потребности приложений могут быть удовлетворены взаимно заметными пакетами._

**Рисунок 11.8 Добавление продукта в пакет.**

Другой способ сделать это — поместить протоколы в пакеты. Тогда пакеты партии, продукта и контракта объединяются, а старым пакетам соответствуют три отдельных протокола. Приложения выбирают протоколы так же, как они выбирают пакеты, показанные на рис. 11.8.

Подводя итог, можно сказать, что когда типы естественным образом тесно связаны друг с другом, у нас есть три варианта. Мы можем разделить типы, сделав ассоциации односторонними (но это усложняет задачу для пользователя типов). Мы можем поместить их в один большой пакет (но это означает, что любой пользователь пакета будет иметь доступ ко всему пакету, даже если нужна только его часть). Мы можем иметь два взаимно видимых пакета (но это вносит циклы в структуру пакета). Если у вас есть протоколы на пакетах, вы можете иметь один большой пакет с отдельными протоколами.

## 11.3 Подтипизация пакетов  {id="11-3-subtyping-packages"}

Видимость проще всего рассматривать при подтипировании. Подтип всегда должен видеть супертип, но мы должны избегать обратного. Поэтому мы добавляем комбинации, опции и барьеры (описанные в [главе 10](10.derrivative-contracts.md)), как показано на рис. 11.9.

![](11.9.png){id="img11.9"}

_Подтипы должны быть видны своим супертипам, но не наоборот._

**Рисунок 11.9 Добавление различных типов опций.**

Мы также должны избегать взаимной видимости между подтипом и его супертипом. Суть подтипизации заключается в том, чтобы позволить типу быть расширенным без того, чтобы об этом знал супертип. Если мы проектируем типы так, чтобы супертипы знали о своих подтипах, то будущая специализация, скорее всего, будет более сложной, поскольку мы встроили предположения о подтипизации в супертип. Любые усилия по устранению таких зависимостей окупаются последующими усовершенствованиями. Правильное проектирование супертипов обычно требует опыта проектирования нескольких подтипов, поэтому лучше не исправлять супертип до тех пор, пока не будет собрано несколько подтипов.



## 11.4 Заключительные размышления {id="11-4-concluding-thoughts"}

Наглядность всегда предполагает компромиссы. Ограничение видимости снижает удобство навигации по модели. При большом количестве односторонних видимостей перемещение по модели может напоминать перемещение по городу с большим количеством улиц с односторонним движением. Двусторонние возможности значительно упрощают навигацию, а значит, требуется меньше кода для написания и поддержки. Однако за такие возможности приходится платить. Чем больше частей системы видят друг друга, тем сложнее контролировать последствия изменений в модели. Ограничение видимости уменьшает эту взаимозависимость.

Разные разработчики ОО-моделей по-разному идут на этот компромисс. Некоторые сильно ограничивают видимость, используя такие приемы, как односторонние ассоциации и графы видимости типов. Я считаю это слишком ограничительным. Я рассматриваю видимость на уровне пакетов, а не типов. Архитектура, представленная в [главе 12](12.layered-arch-for-cs.md), разделяет систему на основные уровни. Внутри уровня домена можно использовать дополнительные ограничения видимости, но это редко бывает просто. Однако я предпочитаю этот подход из-за своего опыта работы с информационными системами. Другие виды разработок требуют иных компромиссов.

В большинстве проектов архитектура пакетов не рассматривается в деталях. Зачастую в них присутствуют только базовые слои архитектуры, если вообще присутствуют. Это приводит к недостаткам для проекта и затрудняет оценку ценности правильно реализованной архитектурной модели. Только большая практика позволит нам лучше понять обсуждаемые здесь компромиссы.

Если разработка пакетной архитектуры сложна для одного проекта, то при попытке интегрировать информационные системы для крупной организации сложность возрастает в десятки раз. Крупные организации страдают от множества систем, которые не могут взаимодействовать между собой. Даже если аппаратное и программное обеспечение будет доведено до ума, такая интеграция окажется невозможной из-за различий в концепциях, лежащих в основе систем. Одним из общепризнанных решений является моделирование в масштабах всей организации. Однако проблема этого подхода заключается в том, что он занимает слишком много времени. К тому времени, когда он будет завершен, если вообще будет завершен, усилия обычно дискредитируются и устаревают. Я считаю, что существует верхний предел размера куска моделирования, с которым можно справиться за один раз, и он связан с созданием полезных систем, которые оправдывают затраты на моделирование в течение разумного периода времени. Для их интеграции необходимо использовать более оппортунистический подход. Я считаю, что для этой задачи пакеты и видимости являются необходимыми инструментами. Их недостаточно для решения этой задачи, и я не берусь утверждать, что знаю, что еще необходимо. Такая интеграция в масштабах предприятия еще мало изучена, и, как и многие, я только узнал, чего делать не следует!

## Ссылки {id="ref"}

1. Wirfs-Brock, R., B. Wilkerson, and L. Wiener. _Designing Object-Oriented Software_. Englewood Cliffs, NJ: Prentice-Hall, 1990.