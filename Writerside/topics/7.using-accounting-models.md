# 7. Использование моделей учета

<secondary-label ref="wip"/>

 Чтобы полностью понять эту главу, вам нужно сначала прочитать [главу 6](6.inventory-accounting.md). Это необычная глава в данной книге. Вместо того чтобы описывать группу паттернов, эта глава показывает, как мы можем использовать паттерны, представленные в предыдущей главе. Это непростая задача, потому что бухгалтерские паттерны довольно абстрактны. Чтобы понять, как на самом деле работают паттерны, нам нужно рассмотреть полностью рабочий пример. 

 В этой главе рассматриваются счета и правила проводок, используемые в модели телефонной компании Total Telecommunications (TT). В лучших традициях учебников примеры, представленные здесь, несколько упрощены. Их должно быть достаточно, чтобы вы хотя бы почувствовали, как работают модели. Цель состоит в том, чтобы проиллюстрировать использование модели счета, а не моделировать телефонную компанию. 

 Поскольку это глава с примерами, я использовал некоторый код, чтобы проиллюстрировать примеры. Я выбрал Digitalk Smalltalk вместо C++, потому что с помощью Smalltalk мне проще передать основные идеи. Концепции должны быть легко переносимы на C++. При преобразовании моделей я использовал паттерны из [главы 14](14.Patterns-for-type-model-design-templates.md). Я также использовал паттерны кодирования Кента Бека [[1](#references)], с некоторыми вариациями. Должен подчеркнуть, что я не предпринимал никаких попыток оптимизировать код. Я также не привел полный код, а только его основные моменты. 

 Базовый тарифный план TT очень прост. Все звонки делятся на дневные и вечерние. Дневной период длится с 7:00 утра до 7:00 вечера. Классификация основана на времени начала звонка.(Для простоты я опустил случай, когда звонок пересекает границу). Дневные звонки стоят 98 центов за первую минуту и 30 центов за последующие минуты. Вечерние звонки стоят 70 центов за первую минуту, 20 центов за последующие 20 минут и 12 центов за все последующее время. Правительство взимает 6% налог с первых 50 долларов США за календарный месяц и 4% с последующих звонков.  

 Глава начинается с обсуждения структурных моделей ([7.1](#7-1)), которые, естественно, основаны на паттернах, представленных в [главе 6](6.inventory-accounting.md). Затем мы рассмотрим некоторые интересные особенности реализации структуры ([7.2](#7-2)). Чтобы настроить объекты, мы начинаем с создания новых телефонных служб ([7.3](#7-3)), а затем настраиваем звонки ([7.4](#7-4-setting-up-calls)). Затем мы впервые рассмотрим правила проводки, изучив код для реализации запуска на основе учетной записи ([7.5](#7-5-implementing-account-based-firing)). Приводятся три примера правил проводки: разделение звонков на дневные и вечерние ([7.6](#7-6-separating-calls-into-day-and-evening)), тарификация по времени ([7.7](#7-7-charging-for-time)) и расчет налога ([7.8](#7-8-calculating-the-tax)). Каждое правило иллюстрирует определенный аспект поведения. Первые два правила действуют на основе каждой проводки, а общий супертип - правило проводки каждой проводки - управляет общим поведением. Разделение платежей на дневные и вечерние осуществляется с помощью простого подтипа синглтон каждого правила проводки. Для дневных и вечерних звонков требуется разная шкала, но поскольку основной процесс одинаков, мы можем использовать объект стратегии, параметризованный таблицей тарифов. Это позволит нам работать с любым правилом проводки, которое взимает плату в соответствии с некоторой шкалой, основанной на длительности звонка. Таким образом класс таблицы тарифов, используемый в качестве объекта стратегии, может быть использован для любых расчетов, основанных на длине. Действительно, он используется для следующего правила проводки, которое рассчитывает налог. В отличие от предыдущих правил, это правило должно работать по месяцам, но мы не можем считать, что оно выполняется один раз в месяц. 

 Три класса правил проводки должны дать представление о том, как можно использовать шаблоны счета/инвентаря для отображения как денежных, так и неденежных операций. 

 При разработке кода мне нравится начинать с построения скелета структурной модели. Затем я создаю прототип, следя за тем, чтобы обновлять структурную модель по ходу работы (иначе я могу забыть, где нахожусь). При возникновении сложных моделей поведения я могу использовать диаграммы событий или диаграммы взаимодействия в начале или в процессе программирования. Если я считаю важным документировать то, что я сделал с этими поведениями (как я делаю для этой книги), я создаю диаграммы после того, как разберусь с кодом. Диаграммы не заменяют код; они помогают проиллюстрировать, что делает код. (Однако, при наличии подходящего инструмента, диаграммы событий можно использовать как код).

## 7.1 Структурные модели

 Лучше всего начать со структурных моделей, поскольку они дают представление о различных частях окончательной модели. На рисунке 7.1 показаны пакеты внутри модели. Я разделил модель на два пакета: телефонные услуги и счета. Одно из достоинств системы бухгалтерского учета заключается в том, что она может использоваться для различных отраслей, поэтому нам нужно убедиться, что модель бухгалтерского учета отделена от любых отраслевых концепций (то есть не имеет связи с ними).  

 ![](7.1.png){id="img7.1"}

_Пакет Счета содержит абстрактные типы учета, которые расширяются пакетом Телефонный сервис для данного конкретного домена._

 **Рисунок 7.1. Пакеты для примера TT.**    

 На рисунке 7.2 показана модель учета для TT, основанная на шаблонах из [главы 6](6.inventory-accounting.md). В этой модели есть три ассоциации от правила проводки к счету. Триггер и выход знакомы, но выход с ключом - это что-то новое. Это позволяет использовать несколько целевых счетов для тех правил проводки, которым они необходимы. Необходимость этого станет понятна на примерах, приведенных далее в главе.  

![](7.2.png){id="img7.2"}

**Рисунок 7.2. Модель счетов для TT.**

 На [рисунке 7.3](#img7.3) показана модель телефонной службы. Клиентам разрешено использовать несколько телефонных линий. Телефонная служба - это фактически телефонная линия, закрепленная за клиентом. Каждая телефонная услуга привязана к учетной практике, которая описывает, как услуга будет выставляться. Эта диаграмма иллюстрирует, почему маппинг темы (линия между детальным счетом и объектом) было добавлено к детализированному счету, показанному на рисунке 7.2. Нам нужен способ узнать, что именно учитывает детальный счет, но мы не хотим, чтобы из пакета счета можно было попасть в пакет телефонных услуг, поскольку это поставит под угрозу повторное использование. Таким образом, мы формируем подтип подробного счета. При подтипизации видимость идет только от подтипа к супертипу. Вполне допустимо, чтобы счет обслуживания знал телефонную службу, потому что они оба находятся в пакете телефонной службы. Однако мы можем ссылаться на детальный счет и не знать, что он является сервисным счетом. Абстрактное отображение счета деталей говорит нам, что счет деталей может быть связан с объектом (тип не определен) в качестве субъекта. Все это будет реализовано подтипами счета деталей - классический случай полиморфизма.  

![](7.3.png){id="img7.3"} 

 **Рисунок 7.3. Структурная модель телефонного сервиса.**  


## 7.2 Реализация структуры 

 Для реализации моделей мы можем использовать шаблоны проектирования, основанные на паттернах, описанных в [главе 14](14.Patterns-for-type-model-design-templates.md). Все ассоциации представлены операциями access и modify. Однозначные отображения следуют обычной конвенции Smalltalk. Так, отображение с именем `trigger` в правиле проводки реализуется триггером `accessor` и триггером `modifier: anAccount`. Многозначные отображения - например, правила проводок по бухгалтерской практике - имеют аксессор `postingRules` и модификаторы `addPostingRule: aPostingRule` и `removePostingRule: aPostingRule`. 

 Операция записи на счет является полиморфной - подробный счет возвращает переменную экземпляра, а суммарный счет суммирует все свои дочерние элементы (как показано в листинге 7.1).  

```
Account»entries
  ^self subclassResponsibility
SummaryAccount»entries
  |answer|
  answer := SortedCollection sortBlock:[:a :b| a whenBooked > b whenBooked].
  self detailAccounts
    inject: answer
    into:
        [:total :each |
        total addAll: each entries;
        yourself].
  ^answer
Detail Account»entries
  ^entries copy
```
{collapsible="true" collapsed-title="Листинг 7.1. Получение записей по счету."}

 В этой модели нет типов счетов. Правила проводок определяются суммарными счетами. Для примеров в этой главе мы можем использовать как типы счетов, так и сводные счета для определения правил проводок. Использование сводных счетов немного сложнее, что делает его лучшей иллюстрацией. Определенные сводные счета высокого уровня хранятся в переменной в классе счета и доступны с помощью метода класса `findWithName: aString`, в соответствии со стилем [раздела 14.5.1](14.Patterns-for-type-model-design-templates.md#14-5-entry-point). 

 Различные фрагменты кода должны найти счет обслуживания для конкретной телефонной службы под конкретным суммарным счетом. Нетрудно придумать различные способы сделать это: попросить телефонную службу найти счет по заданному суммарному счету или попросить суммарный счет найти его потомка, привязанного к телефонной службе. Оба эти способа разумны, но трудно выбрать, какой из них лучше. Кроме того, каждый из них подразумевает определенный путь навигации, и один из них может быть лучше другого. В таких случаях мы можем использовать совершенно другую технику, создав метод класса, следуя [разделу 14.5.1](14.Patterns-for-type-model-design-templates.md#14-5-entry-point). Тогда мы сможем реализовать метод с любым из путей и изменить его без изменения декларативного интерфейса. Это также облегчает запоминание того, где находятся эти методы поиска, как показано в листинге 7.2.  

```
ServiceAccount class»findWithPhoneService: aPhoneService topParent: aTopSummaryAccount
   ^aPhoneService serviceAccounts detect: [:i| i parentTop = aTopSummaryAccount]
PhoneService»accountNamed: aString
  ^ServiceAccount
      findWithPhoneService: self
      topParent: (Account findWithName: aString)
```
{collapsible="true" collapsed-title="Листинг 7.2. Поиск конкретного счета. "}
   
 На практике часто удобнее использовать метод на телефонном сервисе, например `accountNamed: aString`. Этот метод вызывает `findWithPhoneService: topParent` и обеспечивает преимущества обоих подходов. 

 Во всех приведенных здесь примерах используются простые транзакции (с только двумя проводками), хотя модель поддерживает сложные транзакции. Мы можем создать простую транзакцию с помощью специальных методов создания транзакции, показанных в листинге 7.3. Один метод несет всю информацию, включая исходные проводки и правило создания проводок. Другой метод используется для начальных атрибутов, считываемых в самом начале. 

```
Transaction class»newWithAmount: aQuantity from: fromAccount to: toAccount
whenCharged: aTimepointOrDate
  ^self
    newWithAmount: aQuantity
    from: fromAccount
    to: toAccount
    whenCharged: aTimepointOrDate
    creator: nil
    sources: Set new
newWithAmount: aQuantity from: fromAccount to: toAccount whenCharged:
aTimepointOrDate creator: aPostingRule sources: aSetOfEntries
^self new
    setAmount: aQuantity
    from: fromAccount
    to: toAccount
    whenCharged: aTimepointOrDate
    creator: aPostingRule
    sources: aSetOfEntries
Transaction»setAmount: aMoney from: aDebitAccount to: aCreditAccount whenCharged:
aTimepointOrDate creator: aPostingRule sources: aSetOfEntries
   "private"
    self require:
        [aMoney isKindOf: Money.
        aDebitAccount isKindOf: ServiceAccount.
        aCreditAccount isKindOf: ServiceAccount.
        (aTimepointOrDate isKindOf: Date) or: [aTimepointOrDate isKindOf: Timepoint].
        (creator == nil) or: [creator isKindOf: PostingRule]].
    self initialize.
    self addEntry: (Entry new
        setAccount: aCreditAccount
        amount: aMoney
        charged: aTimepointOrDate).
    self addEntry: (Entry new
        setAccount: aDebitAccount
        amount: aMoney negated
        charged: aTimepointOrDate).
    creator:= aPostingRule.
    aSetOfEntries do: [:i| self sourcesAdd: i].
    self checklnvariant.
Object»require: aBooleanBlock
  aBooleanBlock value ifFalse: [self error: 'Precondition Violation']
Transaction»checklnvariant
  |balance|
  balance := entries
    inject: Quantity zero
    into: [:total :each | total := total + each amount].
  self require: [balance = Quantity zero].
```
{collapsible="true" collapsed-title="Листинг 7.3. Создание транзакции с двумя проводками." }
{id="code7.3"}

 В листинге показан ряд приемов кодирования. Параметрический метод конструктора [[1](#references)] (с префиксом `set`) инициализирует новый объект параметрами. Внутри параметрического метода создания проверка предварительного условия выполняется с помощью сообщения `require:`. Для повышения производительности проверку можно убрать, переопределив метод `require:`. Еще одним элементом проектирования по контракту [[3](#references)] является использование проверки инвариантов.  

## 7.3 Настройка новой телефонной услуги 

Создание новой телефонной услуги - это не просто инстанцирование объекта телефонной услуги. Необходимо также создать учетные записи услуги, чтобы запустить систему учета. Хотя этот пример не содержит более одной бухгалтерской практики, он должен быть достаточно гибким, чтобы настроить счета для любой используемой бухгалтерской практики, как показано на рисунках 7.4 и 7.5, а также в листинге 7.4.  

![](7.4.png){id="img7.4"}  

_В этой диаграмме используется условие управления между продуктами (расширение обычных диаграмм событий). Управляющее условие оценивается для каждой комбинации входящих в него триггеров, в данном случае для каждой комбинации новой телефонной услуги и счета проводки. Оно вызывает операцию создания счета обслуживания для каждой телефонной услуги и суммарного счета проводки в бухгалтерской практике._

 **Рисунок 7.4. Диаграмма событий при создании новой телефонной услуги**. 

![](7.5.png){id="img7.5"}

 **Рисунок 7.5. Диаграмма взаимодействия при создании новой телефонной услуги.**  

```
PhoneService class»newWithAccountingPractice: anAccountingPractice customer:
aCustomer phoneLine: aPhoneLine
  ^self new
    setAccountingPractice: anAccountingPractice
    customer: aCustomer
    phoneLine: aPhoneLine
PhoneService»setAccountingPractice: anAccountingPractice customer: aCustomer
phoneLine: aString
  |newObj summaryAccounts|
  self require:
    [(anAccountingPractice isKindOf: AccountingPractice) &
    (aCustomer isKindOf: Customer)].
  name := (aCustomer name), '#', (aCustomer phoneServices size + 1) printString.
  accountingPractice := anAccountingPractice.
  self setCustomer: aCustomer.
  line := aString.
  self createServiceAccounts.
  ^self
PhoneService»createServiceAccounts
  "private - initializing"
  (self accountingPractice summaryAccounts) do:
    [:each | ServiceAccount newWithPhoneService: self parent: each].
```
{collapsible="true" collapsed-title="Листинг 7.4. Настройка новой телефонной линии." }

 Чтобы определить, какие счета требуются, у бухгалтерской практики запрашиваются ее счета проводок, как показано на рисунке 7.6 и в листинге 7.5. Практика бухгалтерского учета может содержать правила проводок, которые ссылаются на детальные счета (хотя в данном случае это не делается). Таким образом, счета проводок должны быть отфильтрованы, чтобы сохранить только суммарные счета.  

![](7.6.png){id="img7.6"}  

_Нам нужен счет запуска для каждого правила проводки и все выходные счета для каждого правила проводки._

 **Рисунок 7.6 Поиск счетов проводки.** 

 ```
 AccountingPractice»summaryAccounts
    ^self postingAccounts select: [:each | each isSummary]
AccountingPractice»postingAccounts
  |answer|
  answer := Set new.
  postingRules do:
    [:each |
    answer add: each trigger.
    answer addAll: each outputs].
  ^answer
 ``` 
{collapsible="true" collapsed-title="Листинг 7.5. Бухгалтерская практика может предоставлять свои сводные счета." }


## 7.4 Setting Up Calls
## 7.5 Implementing Account-based Firing
## 7.6 Separating Calls into Day and Evening
## 7.7 Charging for Time
## 7.8 Calculating the Tax
## 7.9 Concluding Thoughts

## References